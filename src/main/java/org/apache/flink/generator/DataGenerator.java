package org.apache.flink.generator;

import java.io.Serializable;
import java.util.Iterator;
import java.util.Objects;
import java.util.Random;

import org.apache.flink.streaming.runtime.operators.windowing.TimestampedValue;

public class DataGenerator implements Iterator<TimestampedValue<String>>, Serializable {

    /**
     * The next event and its various timestamps. Ordered by increasing wallclock timestamp, then
     * (arbitrary but stable) event hash order.
     */
    public static class NextEvent implements Comparable<NextEvent> {
        /** When, in wallclock time, should this event be emitted? */
        public final long wallclockTimestamp;

        /** When, in event time, should this event be considered to have occured? */
        // public final long eventTimestamp;

        /** The string itself. */
        public final String str;

        /** The minimum of this and all future event timestamps. */
        // public final long watermark;

        public NextEvent(long wallclockTimestamp, String str) {
            this.wallclockTimestamp = wallclockTimestamp;
            // this.eventTimestamp = eventTimestamp;
            this.str = str;
            // this.watermark = watermark;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            NextEvent nextEvent = (NextEvent) o;

            return (wallclockTimestamp == nextEvent.wallclockTimestamp
                // && eventTimestamp == nextEvent.eventTimestamp
                // && watermark == nextEvent.watermark
                && str.equals(nextEvent.str));
        }

        @Override
        public int hashCode() {
            return Objects.hash(wallclockTimestamp, str);
        }

        @Override
        public int compareTo(NextEvent other) {
        int i = Long.compare(wallclockTimestamp, other.wallclockTimestamp);
        if (i != 0) {
            return i;
        }
        return Integer.compare(str.hashCode(), other.str.hashCode());
        }
    }

    /** Smallest random string size. */
    private static final int MIN_STRING_LENGTH = 3;

    private final Random random;
  
    // /** Number of events generated by this generator. */
    // private long eventsCountSoFar;
  
    /** Wallclock time at which we emitted the first event (ms since epoch). Initially -1. */
    private long wallclockBaseTime;

    public DataGenerator(long wallclockBaseTime) {
        // this.eventsCountSoFar = eventsCountSoFar;
        this.wallclockBaseTime = wallclockBaseTime;
        // random generator
        this.random = new Random();
    }

    public DataGenerator() {
        this(-1);
    }

    /**
     * Return the next event. The outer timestamp is in wallclock time and corresponds to when the
     * event should fire. The inner timestamp is in event-time and represents the time the event is
     * purported to have taken place in the simulation.
     */
    public NextEvent nextEvent() {
        if (wallclockBaseTime < 0) {
            wallclockBaseTime = System.currentTimeMillis();
        }

        String str = DataGenerator.nextString(random, 20);

        return new NextEvent(wallclockBaseTime, str);
    }


    /** Return a random string of up to {@code maxLength}. */
    public static String nextString(Random random, int maxLength) {
        return nextString(random, maxLength, ' ');
    }

    public static String nextString(Random random, int maxLength, char special) {
        int len = MIN_STRING_LENGTH + random.nextInt(maxLength - MIN_STRING_LENGTH);
        StringBuilder sb = new StringBuilder();
        while (len-- > 0) {
        if (random.nextInt(13) == 0) {
            sb.append(special);
        } else {
            sb.append((char) ('a' + random.nextInt(26)));
        }
        }
        return sb.toString().trim();
    }

    @Override
    public boolean hasNext() {
        return true; // need to change the number
    }

    @Override
    public TimestampedValue<String> next() {
        NextEvent next = nextEvent();
        return new TimestampedValue<>(next.str, next.wallclockTimestamp);
    }
}